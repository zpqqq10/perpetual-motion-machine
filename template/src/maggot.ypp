%{
#include <iostream>
#include <string>
#include "main.h"
#include "declaration.h"
#include "expression.h"
using namespace std;

extern Program* prog;
VarDeclList vardecllist;

extern int yylex(void);

extern int yyparse();
int yyerror(const char *s);

%}

%union
{
	BaseAST* node;
	int valueType;
	std::string* str;
	char Op;
	std::string* valuetext;
	// BaseAST* node;
}

%token COLON SEMICOLON COMMA LEFTP RIGHTP LEFTB RIGHTB LEFTSB RIGHTSB DQUOTE SQUOTE
%token RETURN FOR IN TO WHILE IF ELSE BREAK
%token <str> IDENTIFIER STRING_VALUE COMMENT
%token <valuetext> INT FLOAT BOOL VOID STRING
%token <valuetext> INTEGER_VALUE FLOAT_VALUE FALSE TRUE
%token ASSIGN GT LT EQ NEQ GE LE AND OR XOR

%left  <Op> GT LT EQ NEQ GE LE
%left  <Op> ADD SUB
%left  <Op> MUL DIV
%right <Op> UMINUS

// %type <varDecl> var

%type <valueType> type_specifier
%type <node> value factor term variable expression addition relation_expr stmt
%start program

%%

program: decl_list {;}
	   ;

decl_list: decl_list decl {;}
		 | decl {;}
		 ;

// one declaration of global variables or a function
// vardecllist.print(1)
decl: var_decl {
		for(size_t i = 0; i<vardecllist.size(); i++){
			prog->children.push_back(vardecllist[i]);
		}
		vardecllist.clear();
	}
	| func_decl {;}
	| proto_decl {;}
	;

// variable declaration
var_decl: type_specifier vars SEMICOLON {vardecllist.settype($1);}
		| COMMENT {;} // *this COMMENT raises a s/r conflict 
		; 

vars: vars COMMA var {;}
	| var {;}
	;

var: IDENTIFIER {vardecllist.addvar(new VarDeclAST(*$1));}
   | IDENTIFIER LEFTSB INTEGER_VALUE RIGHTSB {vardecllist.addvar(new VarDeclAST(*$1, 999));}
   | IDENTIFIER ASSIGN expression {vardecllist.addvar(new VarDeclAST(*$1));}
   ;

type_specifier: INT {$$ = TYPEINT;}
			  | FLOAT {$$ = TYPEFLOAT;}
			  | BOOL {$$ = TYPEBOOL;}
			  | VOID {$$ = TYPEVOID;}
			//   | STRING {$$ = TYPEINT;}
			  ;

// function declaration
func_decl: type_specifier IDENTIFIER LEFTP params RIGHTP compound_stmt {prog->children.push_back(new FuncAST($1, *$2));}
		 ;

proto_decl: type_specifier IDENTIFIER LEFTP params RIGHTP SEMICOLON {prog->children.push_back(new FuncAST($1, *$2));}
		  ;


// parameters of a function declaration or a function definition
params: param_list {;}
	  | VOID {;}
	  | {;}
	  ;

param_list: param_list COMMA param {;}
		  | param {;}
		  ;

param: type_specifier IDENTIFIER {;}
	 | type_specifier IDENTIFIER LEFTSB RIGHTSB {;}
	 ;

// begin with { and end with }
compound_stmt: LEFTB local_decls stmt_list RIGHTB {;}
			 ;

local_decls: local_decls var_decl {vardecllist.clear();;}
		   | {;}
		   ;

// statements
stmt_list: stmt_list stmt {;}
		 | {;}
		 ;

stmt: expression_stmt {$$ = $1;}
	| compound_stmt {;}
	| selection_stmt {;}
	| iteration_stmt {;}
	| return_stmt {;}
	| COMMENT {;}
	;

// expression
expression_stmt: expression SEMICOLON {;}
			   | SEMICOLON {;}
			   ;

// if else
selection_stmt: IF LEFTP expression RIGHTP stmt {;}
			  | IF LEFTP expression RIGHTP stmt ELSE stmt {;} // *this dangling ELSE raises a s/r conflict 
			  ;

// while
iteration_stmt: WHILE LEFTP expression RIGHTP stmt {;}
			  ;

// return
return_stmt: RETURN SEMICOLON {;}
		   | RETURN expression SEMICOLON {;}
		   ;

expression: variable ASSIGN expression {$$ = new BinaryOpAST(OPASSIGN); $$->children.push_back($1); $$->children.push_back($3);prog->children.push_back($$);}
		  | relation_expr {$$ = $1;}
		  ;

variable: IDENTIFIER {$$ = new VarAST(*$1);}
		| IDENTIFIER LEFTSB expression RIGHTSB {;}
		;

relation_expr: relation_expr LE addition { $$ = new BinaryOpAST(OPLE); $$->children.push_back($1); $$->children.push_back($3);}
			 | relation_expr LT addition { $$ = new BinaryOpAST(OPLT); $$->children.push_back($1); $$->children.push_back($3);}
			 | relation_expr GT addition { $$ = new BinaryOpAST(OPGT); $$->children.push_back($1); $$->children.push_back($3);}
			 | relation_expr GE addition { $$ = new BinaryOpAST(OPGE); $$->children.push_back($1); $$->children.push_back($3);}
			 | relation_expr EQ addition { $$ = new BinaryOpAST(OPEQ); $$->children.push_back($1); $$->children.push_back($3);}
			 | relation_expr NEQ addition {$$ = new BinaryOpAST(OPNEQ); $$->children.push_back($1); $$->children.push_back($3);}
		     | addition {$$ = $1;}
		     ;


// + or -
addition: addition ADD term { $$ = new BinaryOpAST(OPADD); $$->children.push_back($1); $$->children.push_back($3);}
		| addition SUB term { $$ = new BinaryOpAST(OPSUB); $$->children.push_back($1); $$->children.push_back($3);}
		| term {$$ = $1;}
		;

term: term MUL factor { $$ = new BinaryOpAST(OPMUL); $$->children.push_back($1); $$->children.push_back($3);}
	| term DIV factor { $$ = new BinaryOpAST(OPDIV); $$->children.push_back($1); $$->children.push_back($3);}
	| factor {$$ = $1;}
	;

factor: LEFTP expression RIGHTP {$$ = $2;}
	  | SUB factor %prec UMINUS {$$ = new UnaryOpAST(OPUMINUS); $$->children.push_back($2); }
	  | variable {$$ = $1;}
	  | call {;}
	  | value {$$ = $1;}
	  ;

value: INTEGER_VALUE {$$ = new IntegerAST(stoi(*$1));debug("111,%d", stoi(*$1));}
	 | FLOAT_VALUE {$$ = new IntegerAST(stof(*$1));}	
	 | TRUE {$$ = new BoolAST(true);}
	 | FALSE {$$ = new BoolAST(false);}
	 ;

// function call
call: IDENTIFIER LEFTP args RIGHTP {;}
	;

// args of a function call
args: arg_list {;}
	| {;}
	;

arg_list: arg_list COMMA expression {;}
		| expression {;}
		;

%%


int yyerror(const char *s)
{
	error("%s", s);
	return 0;
}

