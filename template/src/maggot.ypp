%{
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <string>
#include "../include/main.h"
#include "../include/utils.h"

using namespace std;
extern int yylex(void);

extern int yyparse();
int yyerror(const char *s);

%}

%union
{
	Block* block;

	int valueType;
	int intval;
	Decl* decl;
	DeclList* declList;
	Stmt* stmt;
	StmtList* stmtList;
	Expr* expr;
	ExprList* exprList;

	FuncBody* funcbody;
	FuncImpl* funcImpl;
	FuncList* funcList;
	char Char;
	char Op;
	char* valueStr;
    string* Str;
}

%token COLON SEMICOLON COMMA LEFTP RIGHTP LEFTB RIGHTB LEFTSB RIGHTSB
%token MAIN RETURN FOR IN TO WHILE IF ELSE BREAK
%token <Str> IDENTIFIER STRING_VALUE
%token <valueStr> INT FLOAT BOOL VOID STRING
%token <valueStr> INTEGER_VALUE FLOAT_VALUE FALSE TRUE

%token ASSIGN GT LT EQ NEQ GE LE AND OR XOR
%left <Op> ADD SUB
%left <Op> MUL DIV

/* %type <block> global main_block function
%type <decl> global_item protoType variable_decl array_decl parameter
%type <declList> decl_list parameters parameter_decl
%type <intval> size
%type <intval> logic_op relation_op
%type <expr> expression relation_expr logic_term logic_expr arith_expr term factor
%type <exprList> variables parameterExprs
%type <stmt> stmt assignment loop condition for_loop while_loop else_block
%type <stmtList> stmt_list
%type <funcbody> function_body
%type <funcImpl> function_impl
%type <funcList> function_list */
%type <valueType> type_specifier
%type <expr> call factor
%start program


%%

/* global variables list + main function + function list */
program: gdecl_list main_func funcs {;}
	   ;

/******** global declaration list ********/
gdecl_list: gdecl_list gdecl SEMICOLON {;}
		  | {;}
		  ;

/* declare some global variables or function prototypes (before main function) */
gdecl: var_decl {;}
	 | prototype {;}
	 ;

/* variable declaration */
var_decl: type_specifier vars {;}
		;

vars: vars COMMA var {; }
	| var {;}
	;

var: IDENTIFIER {;}
   /* int a; */
   | IDENTIFIER LEFTSB INTEGER_VALUE RIGHTSB {;}
   /* int a[2]; */
   | IDENTIFIER LEFTSB RIGHTSB {;}
   /* int a[]; */
   | IDENTIFIER ASSIGN INTEGER_VALUE {;}
   /* int a = 2; */
   ;

type_specifier: INT {$$ = VALUEINT;}
			  | FLOAT {$$ = VALUEFLOAT;}
			  | STRING {$$ = VALUESTRING;}
			  | BOOL {$$ = VALUEBOOL;}
			  | VOID {$$ = VALUEVOID;}
			  ;

/******** global prototype list ********/
/* int foo(int x, int y) */
prototype: type_specifier IDENTIFIER LEFTP paras RIGHTP {;}
		 | type_specifier IDENTIFIER LEFTP RIGHTP {;}
		 ;

/* int x, int y */
paras: paras COMMA para {;}
	 | para {;}
	 ;

para: type_specifier IDENTIFIER {;}
	| type_specifier IDENTIFIER LEFTSB INTEGER_VALUE RIGHTSB {;}
	| type_specifier IDENTIFIER LEFTSB RIGHTSB {;}
	;

/******** main function implementation ********/
/* int main(){} */
main_func: INT MAIN LEFTP RIGHTP compound_stmt {;}
		 | VOID MAIN LEFTP RIGHTP compound_stmt {;}
		 ;

/******** function implementation ********/
funcs: funcs func {;}
	 | {;}
	 ;

func: prototype compound_stmt {;}
	;

/* all the local variables should be declared at first */
/* and then the statements */
/* begin with { and end with } */
compound_stmt: LEFTB localvars stmt_list RIGHTB {;}
		;

localvars: localvars var_decl SEMICOLON {;}
		 | {;}
		 ;

stmt_list: stmt_list stmt {;}
		 | {;}
		 ;

/******** statements ********/
stmt: expression_stmt {;}
	| compound_stmt {;}
	| selection_stmt {;}
	| loop_stmt {;}
	| return_stmt {;}
	;

expression_stmt: expression SEMICOLON {;}
			   | SEMICOLON {;}
			   ;

selection_stmt: IF LEFTP expression RIGHTP compound_stmt {;}
			  | IF LEFTP expression RIGHTP compound_stmt ELSE compound_stmt {;}
			  ;

loop_stmt: for_loop {;}
		 | while_loop {;}
		 ;

return_stmt: RETURN SEMICOLON {;}
		   | RETURN expression SEMICOLON {;}
		   ;

for_loop: FOR LEFTP expression SEMICOLON expression SEMICOLON expression RIGHTP compound_stmt {;}
		| FOR LEFTP var_decl SEMICOLON expression SEMICOLON expression RIGHTP compound_stmt {;}
		; 

while_loop: WHILE LEFTP expression RIGHTP compound_stmt {;}
		  ;
		  
expression: IDENTIFIER ASSIGN expression {;}
		  /* a = 2 */
		  | IDENTIFIER LEFTSB expression RIGHTSB ASSIGN expression {;}
		  /* a[1] = 2 */
		  | simpleexpr {;}
		  | {;}
		  ;

simpleexpr: addition {;}
		  | addition relationop addition {;}
		  | logic {;}
		  ;

relationop: LT {;}
		  | GT {;}
		  | EQ {;}
		  | NEQ {;}
		  | LE {;}
		  | GE {;}
		  ;

/* ? may be error here */
logic: logic OR factor {;}
	 | logic AND factor {;}
	 | logic XOR factor {;}
	 | factor {;}
	 ;

addition: addition ADD term {;}
		| addition SUB term {;}
		| term {;}
		;

term: term MUL factor {;}
	| term DIV factor {;}
	| factor {;}
	;

factor: LEFTP expression RIGHTP {;}
	  | IDENTIFIER {$$ = new Identifier(*$1);}
	  | IDENTIFIER LEFTSB expression RIGHTSB {$$ = new ArrEExpr($1, $3);}
	  | call {;}
	  | INTEGER_VALUE {$$ = new Integer(atoi($1));}
	  | FLOAT_VALUE {$$ = new Float(atof($1));}
	  | TRUE {$$ = new Float(atof(true));}
	  | FALSE {$$ = new Float(atof(false));}
	  /* | STRING_VALUE {;} */
	  ;

call: IDENTIFIER LEFTP args RIGHTP {$$ = new Call($1,$3);}
	;

args: arg_list {;}
	| {;}
	;

arg_list: arg_list COMMA expression {;}
		| expression {;}
		;

%%


int yyerror(const char *s)
{
	error("%s", s);
	return 0;
}

