%{
#include <iostream>
#include <string>
#include "main.h"
#include "declaration.h"
#include "expression.h"
using namespace std;

extern Program* prog;
VarDeclList vardecllist;

extern int yylex(void);

extern int yyparse();
int yyerror(const char *s);

%}

%union
{
	BaseAST* node;
	int valueType;
	std::string* str;
	char Op;
	std::string* valuetext;
	// BaseAST* node;
}

%token COLON SEMICOLON COMMA LEFTP RIGHTP LEFTB RIGHTB LEFTSB RIGHTSB DQUOTE SQUOTE
%token RETURN FOR IN TO WHILE IF ELSE BREAK
%token <str> IDENTIFIER STRING_VALUE COMMENT
%token <valuetext> INT FLOAT BOOL VOID STRING
%token <valuetext> INTEGER_VALUE FLOAT_VALUE FALSE TRUE
%token ASSIGN GT LT EQ NEQ GE LE AND OR XOR

%left  <Op> GT LT EQ NEQ GE LE
%left  <Op> ADD SUB
%left  <Op> MUL DIV
%right <Op> UMINUS

// %type <varDecl> var

%type <valueType> type_specifier
%type <node> value factor term
%start program

%%

program: decl_list {;}
	   ;

decl_list: decl_list decl {;}
		 | decl {;}
		 ;

// one declaration of global variables or a function
// vardecllist.print(1)
decl: var_decl {
		for(size_t i = 0; i<vardecllist.size(); i++){
			prog->children.push_back(vardecllist[i]);
		}
		vardecllist.clear();
	}
	| func_decl {;}
	| proto_decl {;}
	;

// variable declaration
var_decl: type_specifier vars SEMICOLON {vardecllist.settype($1);}
		| COMMENT {;} // *this COMMENT raises a s/r conflict 
		; 

vars: vars COMMA var {;}
	| var {;}
	;

var: IDENTIFIER {vardecllist.addvar(new VarDeclAST(*$1));}
   | IDENTIFIER LEFTSB INTEGER_VALUE RIGHTSB {vardecllist.addvar(new VarDeclAST(*$1, 999));}
   | IDENTIFIER ASSIGN expression {vardecllist.addvar(new VarDeclAST(*$1));}
   ;

type_specifier: INT {$$ = TYPEINT;}
			  | FLOAT {$$ = TYPEFLOAT;}
			  | BOOL {$$ = TYPEBOOL;}
			  | VOID {$$ = TYPEVOID;}
			//   | STRING {$$ = TYPEINT;}
			  ;

// function declaration
func_decl: type_specifier IDENTIFIER LEFTP params RIGHTP compound_stmt {prog->children.push_back(new FuncAST($1, *$2));}
		 ;

proto_decl: type_specifier IDENTIFIER LEFTP params RIGHTP SEMICOLON {prog->children.push_back(new FuncAST($1, *$2));}
		  ;


// parameters of a function declaration or a function definition
params: param_list {;}
	  | VOID {;}
	  | {;}
	  ;

param_list: param_list COMMA param {;}
		  | param {;}
		  ;

param: type_specifier IDENTIFIER {;}
	 | type_specifier IDENTIFIER LEFTSB RIGHTSB {;}
	 ;

// begin with { and end with }
compound_stmt: LEFTB local_decls stmt_list RIGHTB {;}
			 ;

local_decls: local_decls var_decl {vardecllist.clear();;}
		   | {;}
		   ;

// statements
stmt_list: stmt_list stmt {;}
		 | {;}
		 ;

stmt: expression_stmt {;}
	| compound_stmt {;}
	| selection_stmt {;}
	| iteration_stmt {;}
	| return_stmt {;}
	| COMMENT {;}
	;

// expression
expression_stmt: expression SEMICOLON {;}
			   | SEMICOLON {;}
			   ;

// if else
selection_stmt: IF LEFTP expression RIGHTP stmt {;}
			  | IF LEFTP expression RIGHTP stmt ELSE stmt {;} // *this dangling ELSE raises a s/r conflict 
			  ;

// while
iteration_stmt: WHILE LEFTP expression RIGHTP stmt {;}
			  ;

// return
return_stmt: RETURN SEMICOLON {;}
		   | RETURN expression SEMICOLON {;}
		   ;

expression: variable ASSIGN expression {;}
		  | relation_expr {;}
		  ;

variable: IDENTIFIER {;}
		| IDENTIFIER LEFTSB expression RIGHTSB {;}
		;

relation_expr: relation_expr LE addition {;}
			 | relation_expr LT addition {;}
			 | relation_expr GT addition {;}
			 | relation_expr GE addition {;}
			 | relation_expr EQ addition {;}
			 | relation_expr NEQ addition {;}
		     | addition {;}
		     ;


// + or -
addition: addition ADD term {;}
		| addition SUB term {;}
		| term {;}
		;

term: term MUL factor {
// 						debug("$1 %d", *$1 == nullptr);
// 						unique_ptr<BaseAST> t = make_unique<BinaryOpAST>(OPMUL);
// 						debug("b %d", t == *$1);
// 						debug("$3 %d", *$3 == nullptr);
// 						 t->children.push_back(move(*$3));
// 						debug("$3 %d", *$3 == nullptr);
// 						 debug("a %d", t == nullptr);
// 						 prog->children.push_back(move(t));
						 }
	| term DIV factor {;}
	// debug("term $1 %d", *$1 == nullptr);$$ = $1;debug("term $1 %d", *$1 == nullptr);
	| factor {;}
	;

factor: LEFTP expression RIGHTP {;}
	  | SUB factor %prec UMINUS {;}
	  | variable {;}
	  | call {;}
	  | value {;}
	  ;

value: INTEGER_VALUE {;}
	 | FLOAT_VALUE {;}	
	 | TRUE {;}
	 | FALSE {;}
	 ;

// function call
call: IDENTIFIER LEFTP args RIGHTP {;}
	;

// args of a function call
args: arg_list {;}
	| {;}
	;

arg_list: arg_list COMMA expression {;}
		| expression {;}
		;

%%


int yyerror(const char *s)
{
	error("%s", s);
	return 0;
}

