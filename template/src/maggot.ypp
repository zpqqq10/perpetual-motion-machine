%{
#include <iostream>
#include <string>
#include "main.h"
#include "declaration.h"
#include "expression.h"
using namespace std;

extern Program* prog;
VarDeclList vardecllist;

extern int yylex(void);

extern int yyparse();
int yyerror(const char *s);

%}

%union
{
	BaseAST* node;
	BaseAST** list;
	int valueType;
	std::string* str;
	char Op;
	std::string* valuetext;
	// BaseAST* node;
}

%token COLON SEMICOLON COMMA LEFTP RIGHTP LEFTB RIGHTB LEFTSB RIGHTSB DQUOTE SQUOTE
%token RETURN FOR IN TO WHILE IF ELSE BREAK
%token <str> IDENTIFIER STRING_VALUE COMMENT
%token <valuetext> INT FLOAT BOOL VOID STRING
%token <valuetext> INTEGER_VALUE FLOAT_VALUE FALSE TRUE
%token ASSIGN GT LT EQ NEQ GE LE AND OR XOR

%left  <Op> GT LT EQ NEQ GE LE
%left  <Op> ADD SUB
%left  <Op> MUL DIV
%right <Op> UMINUS

// %type <varDecl> var

%type <valueType> type_specifier
%type <node> value factor term variable expression addition relation_expr stmt expression_stmt stmt_list compound_stmt vars var var_decl func_decl decl 

%start program

%%

program: decl_list {;}
	   ;

decl_list: decl_list decl {prog->children.push_back($2);}
		 | decl {prog->children.push_back($1);}
		 ;

// one declaration of global variables / function / prototype / comment
decl: var_decl {$$ = $1;}
	| func_decl {$$ = $1;}
	| proto_decl {;}       // ! todo
	| COMMENT {;} 
	;

// variable declaration
var_decl: type_specifier vars SEMICOLON {$$ = $2; dynamic_cast<VarDeclList *>$2->settype($1);}
		; 

vars: vars COMMA var {$$ = $1;dynamic_cast<VarDeclList *>$$->addvar(dynamic_cast<VarDeclAST *>$3);}
	| var {$$ = new VarDeclList();dynamic_cast<VarDeclList *>$$->addvar(dynamic_cast<VarDeclAST *>$1);}
	;

var: IDENTIFIER {$$ = new VarDeclAST(*$1);}
   | IDENTIFIER LEFTSB INTEGER_VALUE RIGHTSB {;}  // ! todo
   | IDENTIFIER ASSIGN expression {$$ = new VarDeclAST(*$1); $$->children.push_back($3);}
   ;

type_specifier: INT {$$ = TYPEINT;}
			  | FLOAT {$$ = TYPEFLOAT;}
			  | BOOL {$$ = TYPEBOOL;}
			  | VOID {$$ = TYPEVOID;}
			//   | STRING {$$ = TYPEINT;}
			  ;

// function definition
func_decl: type_specifier IDENTIFIER LEFTP params RIGHTP compound_stmt {BaseAST* f = new FuncAST($1, *$2);f->children.push_back($6);$$ = f;}
		 ;

// prototype declaration
proto_decl: type_specifier IDENTIFIER LEFTP params RIGHTP SEMICOLON {;} // ! todo
		  ;


// parameters of a function declaration or a function definition
params: param_list {;} // ! todo
	  | VOID {;} // ! todo
	  | {;} // ! todo
	  ;

param_list: param_list COMMA param {;} // ! todo
		  | param {;} // ! todo
		  ;

param: type_specifier IDENTIFIER {;} // ! todo
	 | type_specifier IDENTIFIER LEFTSB RIGHTSB {;} // ! todo
	 ;

// begin with { and end with }
compound_stmt: LEFTB stmt_list RIGHTB {$$ = $2;}
			 ;

// statements
stmt_list: stmt_list stmt {
							if($1 == nullptr)
								$$ = new CompoundStmtAST();
							else
								$$ = $1;
							if($2 != nullptr)
								$$->children.push_back($2);

							}
		 | {$$ = nullptr;}
		 ;

stmt: expression_stmt {$$ = $1;}
	| compound_stmt {$$ = $1;}
	| selection_stmt {;} 				// ! todo
	| iteration_stmt {;}				// ! todo
	| return_stmt {;} 					// ! todo
	| var_decl {$$ = $1;}
	| COMMENT {$$ = nullptr;}
	;

// expression
expression_stmt: expression SEMICOLON {$$ = $1;}
			   | SEMICOLON {;}
			   ;

// if else
// this dangling ELSE raises a s/r conflict 
selection_stmt: IF LEFTP expression RIGHTP stmt {;}							// ! todo
			  | IF LEFTP expression RIGHTP stmt ELSE stmt {;} 				// ! todo
			  ;

// while
iteration_stmt: WHILE LEFTP expression RIGHTP stmt {;}						// ! todo
			  ;

// return
return_stmt: RETURN SEMICOLON {;}											// ! todo
		   | RETURN expression SEMICOLON {;}								// ! todo
		   ;

// expression
expression: variable ASSIGN expression {$$ = new BinaryOpAST(OPASSIGN); $$->children.push_back($1); $$->children.push_back($3);}
		  | relation_expr {$$ = $1;}
		  ;

// variable that could appear on the left of a operator
variable: IDENTIFIER {$$ = new VarAST(*$1);}
		| IDENTIFIER LEFTSB expression RIGHTSB {;}							// ! todo
		;

relation_expr: relation_expr LE addition { $$ = new BinaryOpAST(OPLE); $$->children.push_back($1); $$->children.push_back($3);}
			 | relation_expr LT addition { $$ = new BinaryOpAST(OPLT); $$->children.push_back($1); $$->children.push_back($3);}
			 | relation_expr GT addition { $$ = new BinaryOpAST(OPGT); $$->children.push_back($1); $$->children.push_back($3);}
			 | relation_expr GE addition { $$ = new BinaryOpAST(OPGE); $$->children.push_back($1); $$->children.push_back($3);}
			 | relation_expr EQ addition { $$ = new BinaryOpAST(OPEQ); $$->children.push_back($1); $$->children.push_back($3);}
			 | relation_expr NEQ addition {$$ = new BinaryOpAST(OPNEQ); $$->children.push_back($1); $$->children.push_back($3);}
		     | addition {$$ = $1;}
		     ;


// + or -
addition: addition ADD term { $$ = new BinaryOpAST(OPADD); $$->children.push_back($1); $$->children.push_back($3);}
		| addition SUB term { $$ = new BinaryOpAST(OPSUB); $$->children.push_back($1); $$->children.push_back($3);}
		| term {$$ = $1;}
		;

// * or /
term: term MUL factor { $$ = new BinaryOpAST(OPMUL); $$->children.push_back($1); $$->children.push_back($3);}
	| term DIV factor { $$ = new BinaryOpAST(OPDIV); $$->children.push_back($1); $$->children.push_back($3);}
	| factor {$$ = $1;}
	;

factor: LEFTP expression RIGHTP {$$ = $2;}
	  | SUB factor %prec UMINUS {$$ = new UnaryOpAST(OPUMINUS); $$->children.push_back($2); }
	  | variable {$$ = $1;}
	  | call {;}									// ! todo
	  | value {$$ = $1;}
	  ;

value: INTEGER_VALUE {$$ = new IntegerAST(stoi(*$1));}
	 | FLOAT_VALUE {$$ = new IntegerAST(stof(*$1));}	
	 | TRUE {$$ = new BoolAST(true);}
	 | FALSE {$$ = new BoolAST(false);}
	 ;

// function call
call: IDENTIFIER LEFTP args RIGHTP {;}					// ! todo
	;

// args of a function call
args: arg_list {;}										// ! todo
	| {;}
	;

arg_list: arg_list COMMA expression {;}					// ! todo
		| expression {;}
		;

%%


int yyerror(const char *s)
{
	error("%s", s);
	return 0;
}

