%{
#include <iostream>
#include <string>
#include "../include/main.h"
#include "../include/utils.h"
#include "../include/declaration.h"
using namespace std;

extern Program* prog;

extern int yylex(void);

extern int yyparse();
int yyerror(const char *s);

%}

%union
{
	// BaseAST* base;
	int valueType;
	std::string* str;
	char Op;
	char* valuetext;
}

%token COLON SEMICOLON COMMA LEFTP RIGHTP LEFTB RIGHTB LEFTSB RIGHTSB DQUOTE SQUOTE
%token RETURN FOR IN TO WHILE IF ELSE BREAK
%token <str> IDENTIFIER STRING_VALUE COMMENT
%token <valuetext> INT FLOAT BOOL VOID STRING
%token <valuetext> INTEGER_VALUE FLOAT_VALUE FALSE TRUE
%token ASSIGN GT LT EQ NEQ GE LE AND OR XOR

%left  <Op> GT LT EQ NEQ GE LE
%left  <Op> ADD SUB
%left  <Op> MUL DIV
%right <Op> UMINUS

%type <valueType> type_specifier
%start program

%%

program: decl_list {;}
	   ;

decl_list: decl_list decl {;}
		 | decl {;}
		 ;

// one declaration of a variable or a function
decl: var_decl {;}
	| func_decl {;}
	| proto_decl {;}
	;

// variable declaration
var_decl: type_specifier vars SEMICOLON {;}
		| COMMENT {;} // *this COMMENT raises a s/r conflict 
		; 

vars: vars COMMA var {;}
	| var {;}
	;

var: IDENTIFIER {;}
   | IDENTIFIER LEFTSB INTEGER_VALUE RIGHTSB {;}
   | IDENTIFIER ASSIGN expression {;}
   ;

type_specifier: INT {$$ = TYPEINT;}
			  | FLOAT {$$ = TYPEFLOAT;}
			  | BOOL {$$ = TYPEBOOL;}
			  | VOID {$$ = TYPEVOID;}
			//   | STRING {$$ = TYPEINT;}
			  ;

// function declaration
func_decl: type_specifier IDENTIFIER LEFTP params RIGHTP compound_stmt {;}
		 ;

proto_decl: type_specifier IDENTIFIER LEFTP params RIGHTP SEMICOLON {prog->children.push_back(make_unique<FuncAST>($1, *$2));}
		  ;


// parameters of a function declaration or a function definition
params: param_list {;}
	  | VOID {;}
	  | {;}
	  ;

param_list: param_list COMMA param {;}
		  | param {;}
		  ;

param: type_specifier IDENTIFIER {;}
	 | type_specifier IDENTIFIER LEFTSB RIGHTSB {;}
	 ;

// begin with { and end with }
compound_stmt: LEFTB local_decls stmt_list RIGHTB {;}
			 ;

local_decls: local_decls var_decl {;}
		   | {;}
		   ;

// statements
stmt_list: stmt_list stmt {;}
		 | {;}
		 ;

stmt: expression_stmt {;}
	| compound_stmt {;}
	| selection_stmt {;}
	| iteration_stmt {;}
	| return_stmt {;}
	| COMMENT {;}
	;

// expression
expression_stmt: expression SEMICOLON {;}
			   | SEMICOLON {;}
			   ;

// if else
selection_stmt: IF LEFTP expression RIGHTP stmt {;}
			  | IF LEFTP expression RIGHTP stmt ELSE stmt {;} // *this dangling ELSE raises a s/r conflict 
			  ;

// while
iteration_stmt: WHILE LEFTP expression RIGHTP stmt {;}
			  ;

// return
return_stmt: RETURN SEMICOLON {;}
		   | RETURN expression SEMICOLON {;}
		   ;

expression: variable ASSIGN expression {;}
		  | relation_expr {;}
		  ;

variable: IDENTIFIER {;}
		| IDENTIFIER LEFTSB expression RIGHTSB {;}
		;

relation_expr: relation_expr LE addition {;}
			 | relation_expr LT addition {;}
			 | relation_expr GT addition {;}
			 | relation_expr GE addition {;}
			 | relation_expr EQ addition {;}
			 | relation_expr NEQ addition {;}
		     | addition {;}
		     ;


// + or -
addition: addition ADD term {;}
		| addition SUB term {;}
		| term {;}
		;

term: term MUL factor {;}
	| term DIV factor {;}
	| factor {;}
	;

factor: LEFTP expression RIGHTP {;}
	  | SUB factor %prec UMINUS {;}
	  | variable {;}
	  | call {;}
	  | value {;}
	  ;

value: INTEGER_VALUE {;}
	//  | SUB INTEGER_VALUE {;}
	 | FLOAT_VALUE {;}
	 | TRUE {;}
	 | FALSE {;}
	 ;

// function call
call: IDENTIFIER LEFTP args RIGHTP {;}
	;

// args of a function call
args: arg_list {;}
	| {;}
	;

arg_list: arg_list COMMA expression {;}
		| expression {;}
		;

%%


int yyerror(const char *s)
{
	error("%s", s);
	return 0;
}

